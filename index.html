<script>
(() => {
  const E  = (sel, root=document) => root.querySelector(sel);
  const EA = (sel, root=document) => Array.from(root.querySelectorAll(sel));

  const errBox   = E('#error');
  const statusBox= E('#status');
  const gate     = E('#gate');
  const btnUnlock= E('#unlock');

  const files = [
    'sounds/00.mp3','sounds/01.mp3','sounds/02.mp3',
    'sounds/03.mp3','sounds/04.mp3','sounds/05.mp3',
    'sounds/06.mp3','sounds/07.mp3','sounds/08.mp3'
  ];
  const prelude = 'sounds/all.mp3';
  const groupOf = i => (i<=2?'low': i<=5?'mid':'high');
  const groups = ['low','mid','high'];
  const MAX_ACTIVE = 3;
  const FADE_MS = 4000; // плавность 4 секунды

  let ctx, master, gains=[], buffers=[], preludeBuf=null;
  let active = new Set(), lru = [], groupQueues = {low:[],mid:[],high:[]};
  let preludePlaying = false;
  let preludeSoftLockUntil = 0;

  function setStatus(t){ statusBox.textContent = t; }
  function showErr(msg){ errBox.hidden=false; errBox.textContent=msg; console.error(msg); }

  // Инициализация аудио
  btnUnlock.addEventListener('click', async () => {
    try{
      if (!ctx){
        ctx = new (window.AudioContext || window.webkitAudioContext)({latencyHint:'interactive'});
        master = ctx.createGain(); master.gain.value = 0.95; master.connect(ctx.destination);

        // создаём отдельный Gain для каждого звука
        for (let i=0;i<files.length;i++){
          const g=ctx.createGain();
          g.gain.value=0.0;
          g.connect(master);
          gains[i]=g;
        }

        setStatus('Загружаю звуки…');
        await loadAllAudio();

        // запускаем все лупы с нулевой громкостью — "фоновое дыхание"
        for (let i=0;i<files.length;i++){
          const src = ctx.createBufferSource();
          src.buffer = buffers[i];
          src.loop = true;
          src.connect(gains[i]);
          src.start(0);
        }

        setStatus('Готово. Нажимайте кнопки.');
      }
      await ctx.resume();
      gate.remove();
    }catch(e){ showErr('Не удалось инициализировать звук: '+e.message); }
  });

  async function fetchBuf(url){
    const r=await fetch(url,{cache:'no-cache'});
    if(!r.ok) throw new Error(url+' → '+r.status);
    return await r.arrayBuffer();
  }
  async function decode(url){ return await ctx.decodeAudioData(await fetchBuf(url)); }
  async function loadAllAudio(){
    try{
      buffers = await Promise.all(files.map(decode));
      preludeBuf = await decode(prelude);
    }catch(e){
      showErr('Ошибка загрузки аудио. Проверьте пути и имена файлов.\n'+e.message);
      throw e;
    }
  }

  function fadeTo(param,to,ms=FADE_MS){
    const now=ctx.currentTime;
    param.cancelScheduledValues(now);
    param.setValueAtTime(param.value,now);
    param.linearRampToValueAtTime(to, now+ms/1000);
  }

  function pushLRU(idx){
    lru = lru.filter(i=>i!==idx); lru.push(idx);
    const g=groupOf(idx);
    groupQueues[g]=groupQueues[g].filter(i=>i!==idx);
    groupQueues[g].push(idx);
  }
  function popOldestGlobal(){ if(!lru.length) return; const v=lru.shift(); deactivate(v); }
  function popOldestFromGroup(g){ if(!groupQueues[g].length) return; const v=groupQueues[g].shift(); deactivate(v); }

  function deactivate(idx){
    if (!active.has(idx)) return;
    active.delete(idx);
    lru = lru.filter(i=>i!==idx);
    const g=groupOf(idx); groupQueues[g]=groupQueues[g].filter(i=>i!==idx);
    fadeTo(gains[idx].gain, 0.0);
    E(`.pad[data-idx="${idx}"]`)?.classList.remove('active');
  }
  function activeInGroup(g){ return [...active].filter(i=>groupOf(i)===g); }

  function balanceBeforeOn(idx){
    const gNew=groupOf(idx);
    const counts={low:activeInGroup('low').length, mid:activeInGroup('mid').length, high:activeInGroup('high').length};
    const total=counts.low+counts.mid+counts.high;
    if (total>=MAX_ACTIVE) popOldestGlobal();

    const c={low:activeInGroup('low').length, mid:activeInGroup('mid').length, high:activeInGroup('high').length};
    for (const g of groups){ if (c[g]>=3 && g!==gNew){ popOldestFromGroup(g); return; } }
    if ([c.low,c.mid,c.high].sort().join(',')==='0,1,2' && c[gNew]===0){
      const donor=groups.find(g=>c[g]===2); if(donor){ popOldestFromGroup(donor); return; }
    }
    if (groups.every(g=>c[g]>0) && c[gNew]>0){ popOldestFromGroup(gNew); return; }
  }

  function togglePad(idx, el){
    if (!ctx || ctx.state!=='running') return;
    if (preludePlaying && Date.now()<preludeSoftLockUntil) return;

    if (active.has(idx)){
      deactivate(idx);
    }else{
      balanceBeforeOn(idx);
      active.add(idx);
      pushLRU(idx);
      fadeTo(gains[idx].gain, 1.0);
      el.classList.add('active');
    }
  }

  function random3(){
    const arr=[...Array(9).keys()].sort(()=>Math.random()-0.5).slice(0,3);
    arr.forEach(i=>{
      const el=E(`.pad[data-idx="${i}"]`);
      balanceBeforeOn(i);
      active.add(i);
      pushLRU(i);
      fadeTo(gains[i].gain,1.0);
      el?.classList.add('active');
    });
  }

  function resetAll(){ [...active].forEach(deactivate); }

  async function inhale(){
    if (preludePlaying) return;
    preludePlaying=true;
    preludeSoftLockUntil=Date.now()+10000;
    resetAll();
    await new Promise(r=>setTimeout(r,300));

    // проигрываем all.mp3 один раз, мягкий fade in/out
    const src=ctx.createBufferSource();
    src.buffer=preludeBuf;
    const g=ctx.createGain();
    g.gain.value=0.0;
    src.connect(g); g.connect(master);
    src.start(0);
    g.gain.setValueAtTime(0,ctx.currentTime);
    g.gain.linearRampToValueAtTime(1.0,ctx.currentTime+0.2);
    const tEnd=ctx.currentTime+preludeBuf.duration;
    g.gain.setValueAtTime(1.0,tEnd-0.2);
    g.gain.linearRampToValueAtTime(0.0,tEnd);
    src.onended=()=>{ preludePlaying=false; setStatus('Готово'); };
    setStatus('Вдох…');
  }

  EA('.pad').forEach(el=>el.addEventListener('click',()=>togglePad(+el.dataset.idx, el)));
  E('#btn-random').addEventListener('click',random3);
  E('#btn-reset').addEventListener('click',resetAll);
  E('#btn-inhale').addEventListener('click',inhale);
})();
</script>
